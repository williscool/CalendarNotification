apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlinx-serialization'
apply plugin: "com.facebook.react"
apply plugin: 'jacoco'

//
// SDK-level codes / values cheat sheet:
//
// Level    Codename            Android OS Ver
// 18       JELLY_BEAN_MR2      4.3
// 19       KITKAT              4.4
// 20       KITKAT_WATCH        4.4W
// 21       LOLLIPOP            5.0
// 22       LOLLIPOP_MR1        5.1
// 23       M                   6.0
// 24       N                   7.0
// 25       N_MR1               7.1, 7.1.1
// 26       O                   8.0
// 27       O_MR1               8.1
// 28       P                   9
//

// Check if we're running in a CI environment
def isCiBuild = System.getenv("CI") != null && System.getenv("CI").toBoolean()
// Alternatively, you can also check for GitHub Actions specifically
def isGitHubActions = System.getenv("GITHUB_ACTIONS") != null && System.getenv("GITHUB_ACTIONS").toBoolean()

// used to use this to determine if we should bundle JS. that code wasn't compatible with configuration cache
// so now we just do it ci
def isCIBuild = isCiBuild || isGitHubActions

android {
  compileSdkVersion 34

  // compileKotlin {
  //     kotlinOptions.allWarningsAsErrors = false
  // }
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_17
    targetCompatibility JavaVersion.VERSION_17
  }

  kotlinOptions {
    jvmTarget = JavaVersion.VERSION_17.toString()
  }

  buildFeatures {
    buildConfig true
  }

  configurations.all {
    exclude group: 'xmlpull', module: 'xmlpull'
    exclude group: 'xpp3', module: 'xpp3'
    exclude group: 'xpp3', module: 'xpp3_min'
    
    resolutionStrategy {
      force 'org.objenesis:objenesis:3.3'
      force 'net.bytebuddy:byte-buddy:1.14.11'
      force 'net.bytebuddy:byte-buddy-agent:1.14.11'
    }
  }

  packagingOptions {
    resources {
      excludes += ['META-INF/LICENSE.md']
      excludes += ['META-INF/LICENSE-notice.md']
      excludes += ['META-INF/NOTICE.md']
      excludes += ['META-INF/*.kotlin_module']
      excludes += ['META-INF/AL2.0']
      excludes += ['META-INF/LGPL2.1']
    }
    pickFirst '**/*.so'
  }

  defaultConfig {
    applicationId "com.github.quarck.calnotify"
    minSdkVersion 24
    minSdk 24
    //noinspection ExpiredTargetSdkVersion
    targetSdkVersion 25
    versionCode 4000024
    versionName "7.2.0"

    buildConfigField "long", "TIMESTAMP", System.currentTimeMillis() + "L"

    // Enhanced test instrumentation with JaCoCo and Ultron/Allure
    testInstrumentationRunner "com.atiurin.ultron.allure.UltronAllureTestRunner"
    testInstrumentationRunnerArguments = [
        'coverage': 'true',
        'jacoco-agent.destfile': '/data/data/com.github.quarck.calnotify/files/coverage.ec',
        'jacoco-agent.includes': 'com.github.quarck.calnotify.*'
    ]

    externalNativeBuild {
      cmake{
        abiFilters 'x86_64', 'arm64-v8a'
      }
    }
    
    ndk { 
      abiFilters 'x86_64', 'arm64-v8a'
    }

    // Add packagingOptions to include necessary .so files
    packagingOptions {
      pickFirst '**/*.so'
    }

  }

  configurations {
    all*.exclude group: 'xpp3', module: 'xpp3'
  }

  // Define specific build variants for each architecture
  flavorDimensions "abi"
  
  // Get the architecture from environment variable or project property or default to supporting both
  def buildArch = providers.gradleProperty('BUILD_ARCH')
    .orElse(providers.environmentVariable('BUILD_ARCH'))
    .forUseAtConfigurationTime()

  println "Building for architecture: ${buildArch.orNull ?: 'defaulting to x86_64'}"
  
  productFlavors {
    // Only create arm64v8a flavor if specifically requested
    if (buildArch.orNull == "arm64-v8a") {
      arm64v8a {
        dimension "abi"
        versionNameSuffix "-arm64-v8a"
        ndk {
          abiFilters 'arm64-v8a'  // Only include arm64-v8a libraries
        }
      }
    }
    
    // Create x8664 flavor if specifically requested or no arch specified (default)
    if (buildArch.orNull == "x86_64" || buildArch.orNull == null) {
      x8664 {
        dimension "abi"
        versionNameSuffix "-x86_64"
        ndk {
          abiFilters 'x86_64'  // Only include x86_64 libraries
        }
      }
    }
  }

  buildTypes {
    debug {
      testCoverageEnabled true
      // Add dexOptions for faster builds
      dexOptions {
        javaMaxHeapSize "4g"
        preDexLibraries true
        threadCount = 4
      }
      ndk {
        abiFilters 'x86_64', 'arm64-v8a'
      }
    }
    release {
      testCoverageEnabled true
      minifyEnabled false
      proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
      
      // Add dexOptions for faster builds
      dexOptions {
        javaMaxHeapSize "4g"
        preDexLibraries true
        threadCount = 4
      }

      lintOptions {
        disable 'MissingTranslation'
        abortOnError false
      }
      ndk {
        abiFilters 'x86_64', 'arm64-v8a'
      }
    }

    customDebugType {
      initWith debug
      matchingFallbacks = ['debug']
      debuggable true
    }
  }

  sourceSets {
    main {
      java.srcDirs += 'src/main/kotlin'
      // Add JNI libs directory
      jniLibs.srcDirs = ['src/main/jniLibs']
    }
  }
  namespace 'com.github.quarck.calnotify'

  // Optimize for parallel execution with GitHub runners
  dexOptions {
    javaMaxHeapSize "4g"
    preDexLibraries true
    threadCount = 4
  }

  // Add proper JaCoCo instrumentation for tests
  testOptions {
    unitTests.all {
      jacoco {
        includeNoLocationClasses = true
        excludes = ['jdk.internal.*']
      }
    }
    // Add Robolectric configuration
    unitTests {
      includeAndroidResources = true
    }
  }
}


dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    // Kotlin
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"

    // AndroidX
    // https://mvnrepository.com/artifact/androidx.legacy/legacy-support-v4
    implementation "androidx.legacy:legacy-support-v4:1.0.0"
    implementation "androidx.core:core:$android_core_version"
    implementation "androidx.core:core-ktx:$android_core_version"
    implementation "androidx.appcompat:appcompat:$androidx_lib_version"

    // https://mvnrepository.com/artifact/androidx.recyclerview/recyclerview
    implementation "androidx.recyclerview:recyclerview:1.3.2"

    // https://mvnrepository.com/artifact/androidx.cardview/cardview
    implementation "androidx.cardview:cardview:1.0.0"

    // https://mvnrepository.com/artifact/androidx.palette/palette
    implementation "androidx.palette:palette:1.0.0"

    // Material
    // https://mvnrepository.com/artifact/com.google.android.material/material
    implementation "com.google.android.material:material:1.12.0"
    
    // AndroidX Preference (for modern settings UI with DayNight support)
    implementation "androidx.preference:preference-ktx:1.2.1"
    
    // React Native
    implementation "com.facebook.react:react-android"
    implementation "com.facebook.react:hermes-android"

    // SQLite
    implementation('com.github.requery:sqlite-android:3.45.0') {
        exclude group: 'com.android.support'
        exclude module: 'support-v4'
        // Force specific version to avoid dynamic version resolution
        version {
            strictly '3.45.0'
        }
    }
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
  // Unit test dependencies
    testImplementation 'junit:junit:4.13.2'
    // Add Robolectric dependency
    testImplementation 'org.robolectric:robolectric:4.14'
    // Mockito for unit tests
    testImplementation 'org.mockito:mockito-core:5.16.1'
    testImplementation 'org.mockito.kotlin:mockito-kotlin:5.4.0'
    // MockK for unit tests
    testImplementation 'io.mockk:mockk:1.13.9' // Use standard mockk for unit tests

//    testImplementation 'io.mockk:mockk-android:1.13.9'
//    testImplementation 'io.mockk:mockk-agent:1.13.9'
    
    // Add AndroidX Test dependencies for unit tests
    testImplementation 'androidx.test:core:1.5.0'
    testImplementation 'androidx.test:core-ktx:1.5.0'
    testImplementation 'androidx.test.ext:junit:1.1.5'
    testImplementation 'androidx.test.ext:junit-ktx:1.1.5'

  // Test dependencies - use same versions as main app to avoid conflicts
    androidTestImplementation "androidx.core:core:$android_core_version"
    androidTestImplementation "androidx.core:core-ktx:$android_core_version"
    androidTestImplementation "androidx.appcompat:appcompat:$androidx_lib_version"
    androidTestImplementation "androidx.appcompat:appcompat-resources:$androidx_lib_version"
    androidTestImplementation "androidx.fragment:fragment:$androidx_lib_version"
    androidTestImplementation "androidx.lifecycle:lifecycle-runtime:2.5.1"
    androidTestImplementation "androidx.lifecycle:lifecycle-viewmodel:2.5.1"
    androidTestImplementation "androidx.annotation:annotation:1.4.0"
    androidTestImplementation "androidx.vectordrawable:vectordrawable:1.1.0"
    androidTestImplementation "androidx.vectordrawable:vectordrawable-animated:1.1.0"
    androidTestImplementation "androidx.activity:activity:1.4.0"
    androidTestImplementation "androidx.activity:activity-ktx:1.4.0"
    androidTestImplementation "com.google.android.material:material:1.6.1"
    
    // Android Testing Dependencies
    androidTestImplementation 'androidx.test:runner:1.5.2'
    androidTestImplementation 'androidx.test:rules:1.5.0'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'  // Downgraded for Ultron 2.3.1 compatibility
    androidTestImplementation 'junit:junit:4.13.2'
    
    // Ultron UI Testing Framework (for traditional View-based UI tests)
    // Using 2.3.1 for Kotlin 1.9.x compatibility (2.6.x requires Kotlin 2.x)
    androidTestImplementation 'com.atiurin:ultron:2.3.1'
    androidTestImplementation 'com.atiurin:ultron-allure:2.3.1'
    
    // Additional test dependencies
    androidTestImplementation 'androidx.test:core:1.5.0'
    androidTestImplementation 'androidx.test:core-ktx:1.5.0'
    androidTestImplementation 'androidx.test.ext:junit-ktx:1.1.5'

    // Mockito dependencies
    androidTestImplementation 'org.mockito:mockito-core:5.16.1'
    androidTestImplementation 'org.mockito.kotlin:mockito-kotlin:5.4.0'
    
    // MockK for Kotlin mocking
    androidTestImplementation 'io.mockk:mockk-android:1.13.9'
    androidTestImplementation 'io.mockk:mockk-agent:1.13.9'

    // Jacoco
    androidTestImplementation 'org.jacoco:org.jacoco.core:0.8.12'
}

// https://reactnative.dev/docs/react-native-gradle-plugin
react {
  entryFile = layout.projectDirectory.file("../../index.tsx").asFile
}

apply from: file("../../node_modules/@react-native-community/cli-platform-android/native_modules.gradle"); applyNativeModulesAppBuildGradle(project)

// Configure JaCoCo properly
jacoco {
    toolVersion = "0.8.12"
}

// Configure all tests to use JaCoCo instrumentation
tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

// Configure unit test coverage reports to generate XML and CSV (not just HTML)
tasks.withType(JacocoReport).configureEach { task ->
    // Only configure the unit test coverage reports (create*UnitTestCoverageReport)
    if (task.name.contains('UnitTestCoverageReport')) {
        reports {
            xml.required = true
            html.required = true
            csv.required = true
        }
    }
}

// Add task to generate coverage report for Android tests
task jacocoAndroidTestReport(type: JacocoReport) {
    group = "Reporting"
    description = "Generate JaCoCo coverage reports after running Android tests"
    
    
    reports {
        xml.required = true
        html.required = true
        csv.required = true
        
        // Add output directory configuration for better organization
        html.outputLocation = file("${buildDir}/reports/jacoco/jacocoAndroidTestReport/html")
        xml.outputLocation = file("${buildDir}/reports/jacoco/jacocoAndroidTestReport/xml/report.xml")
        csv.outputLocation = file("${buildDir}/reports/jacoco/jacocoAndroidTestReport/csv/report.csv")
    }
    
    // Get architecture from property or environment, defaulting to x86_64
    def buildArch = providers.gradleProperty('BUILD_ARCH')
        .orElse(providers.environmentVariable('BUILD_ARCH'))
        .orElse('x86_64')
        .forUseAtConfigurationTime()
        .get()
    
    // Convert architecture to variant name format
    def archSuffix = buildArch == 'arm64-v8a' ? 'Arm64V8a' : 'X8664'
    
    // Dynamic paths based on architecture
    def debugVariant = "${archSuffix.toLowerCase()}Debug"
    
    println "Generating JaCoCo report for ${debugVariant} variant"
    
    // Correct source directories to include Kotlin files
    sourceDirectories.setFrom(files([
        'src/main/java',
        'src/main/kotlin'
    ]))
    
    // Use a more targeted approach for class directories
    classDirectories.setFrom(files([
        fileTree(
            dir: "${buildDir}",
            includes: [
                "**/tmp/kotlin-classes/${debugVariant}/**/*.class",
                "**/intermediates/javac/${debugVariant}/classes/**/*.class"
            ],
            excludes: [
                '**/R.class',
                '**/R$*.class',
                '**/BuildConfig.*',
                '**/Manifest*.*',
                '**/*Test*.*',
                '**/com/facebook/react/**',
                '**/com/facebook/hermes/**',
                '**/com/facebook/jni/**',
                '**/org/jacoco/**',
                '**/com/android/tools/jacoco/**'
            ]
        )
    ]))
    
    // Look for the coverage file in ALL possible locations
    executionData.setFrom(fileTree(
        dir: "${buildDir}", 
        includes: [
            "**/outputs/code_coverage/*.ec",
            "**/outputs/code_coverage/**/*.ec",
            "**/outputs/code-coverage/**/*.ec",
            "**/outputs/connected/**/*.ec",
            "**/coverage/**/*.ec",
            "**/outputs/**/*.ec"
        ]
    ))
    
    doFirst {
        println "=== JaCoCo Report Configuration ==="
        println "Architecture: ${buildArch} (${archSuffix})"
        
        println "\nClass Directories:"
        classDirectories.files.each { file ->
            if (file.exists()) {
                def fileCount = 0
                if (file.isDirectory()) {
                    fileCount = file.listFiles()?.size ?: 0
                }
                println " - ${file.absolutePath} (exists with ${fileCount} files)"
            } else {
                println " - ${file.absolutePath} (directory not found)"
            }
        }
        
        println "\nInstrumented Class Search:"
        def classesFound = false
        fileTree(dir: "${buildDir}").matching { 
            include "**/classes/**/*.class"
            include "**/kotlin/compile*/**/*.class"
            include "**/intermediates/javac/**/*.class"
            include "**/tmp/kotlin-classes/**/*.class"
        }.visit { fileDetails ->
            if (fileDetails.name.endsWith(".class") && classesFound == false) {
                println " - Found instrumented classes at: ${fileDetails.file.parentFile.absolutePath}"
                classesFound = true
            }
        }
        
        println "\nCoverage Files:"
        executionData.files.each { file ->
            if (file.exists()) {
                println " - ${file.absolutePath} (exists with size ${file.length()} bytes)"
            } else {
                println " - ${file.absolutePath} (file not found)"
            }
        }
        
        // Only proceed if we have non-empty execution data
        def hasNonEmptyData = false
        executionData.files.each { file ->
            if (file.exists() && file.length() > 0) {
                println "\nâœ… Found non-empty coverage file: ${file.absolutePath} (${file.length()} bytes)"
                hasNonEmptyData = true
            }
        }
        
        if (!hasNonEmptyData) {
            println "\nâŒ No non-empty coverage files found. Report will be empty."
            println "Try running the tests again with: ./scripts/run_android_tests.sh"
        }
    }
    
    // Skip the task if there are no execution data files or they're all empty
    onlyIf { 
        def hasData = false
        executionData.files.each { file ->
            if (file.exists() && file.length() > 0) {
                hasData = true
            }
        }
        return hasData
    }
}

plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'kotlinx-serialization'
    id 'jacoco'
    id 'com.facebook.react'
    id 'com.google.devtools.ksp'  // Using KSP for Room (avoids SQLite JDBC issue on Windows)
}

//
// SDK-level codes / values cheat sheet:
//
// Level    Codename            Android OS Ver
// 18       JELLY_BEAN_MR2      4.3
// 19       KITKAT              4.4
// 20       KITKAT_WATCH        4.4W
// 21       LOLLIPOP            5.0
// 22       LOLLIPOP_MR1        5.1
// 23       M                   6.0
// 24       N                   7.0
// 25       N_MR1               7.1, 7.1.1
// 26       O                   8.0
// 27       O_MR1               8.1
// 28       P                   9
//

// Check if we're running in a CI environment
def isCiBuild = System.getenv("CI") != null && System.getenv("CI").toBoolean()
// Alternatively, you can also check for GitHub Actions specifically
def isGitHubActions = System.getenv("GITHUB_ACTIONS") != null && System.getenv("GITHUB_ACTIONS").toBoolean()

// used to use this to determine if we should bundle JS. that code wasn't compatible with configuration cache
// so now we just do it ci
def isCIBuild = isCiBuild || isGitHubActions

// Read dev page flag from local.properties (gitignored = can't leak to releases)
def localProperties = new Properties()
def localPropertiesFile = rootProject.file('local.properties')
if (localPropertiesFile.exists()) {
    localProperties.load(new FileInputStream(localPropertiesFile))
}
def devPageEnabled = localProperties.getProperty('devPage.enabled', 'false').toBoolean()

android {
  compileSdkVersion rootProject.ext.compileSdkVersion

  // compileKotlin {
  //     kotlinOptions.allWarningsAsErrors = false
  // }
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_17
    targetCompatibility JavaVersion.VERSION_17
  }

  kotlinOptions {
    jvmTarget = JavaVersion.VERSION_17.toString()
  }

  buildFeatures {
    buildConfig true
  }

  configurations.all {
    exclude group: 'xmlpull', module: 'xmlpull'
    exclude group: 'xpp3', module: 'xpp3'
    exclude group: 'xpp3', module: 'xpp3_min'
    
    resolutionStrategy {
      force 'org.objenesis:objenesis:3.3'
      force 'net.bytebuddy:byte-buddy:1.14.11'
      force 'net.bytebuddy:byte-buddy-agent:1.14.11'
      // Force sqlite version for Room 2.8.4 compatibility (overrides consistent resolution constraint)
      force 'androidx.sqlite:sqlite:2.6.2'
      force 'androidx.sqlite:sqlite-framework:2.6.2'
    }
  }

  packagingOptions {
    resources {
      excludes += ['META-INF/LICENSE.md']
      excludes += ['META-INF/LICENSE-notice.md']
      excludes += ['META-INF/NOTICE.md']
      excludes += ['META-INF/*.kotlin_module']
      excludes += ['META-INF/AL2.0']
      excludes += ['META-INF/LGPL2.1']
    }
    jniLibs {
      useLegacyPackaging = true
    }
    pickFirst '**/*.so'
  }

  defaultConfig {
    applicationId "com.github.quarck.calnotify"
    minSdkVersion rootProject.ext.minSdkVersion
    minSdk rootProject.ext.minSdk
    targetSdkVersion rootProject.ext.targetSdkVersion
    versionCode 4000065
    versionName "9.12.1"

    buildConfigField "long", "TIMESTAMP", System.currentTimeMillis() + "L"
    // React Native New Architecture flags
    buildConfigField "boolean", "IS_NEW_ARCHITECTURE_ENABLED", project.hasProperty("newArchEnabled") ? project.property("newArchEnabled") : "false"
    buildConfigField "boolean", "IS_HERMES_ENABLED", project.hasProperty("hermesEnabled") ? project.property("hermesEnabled") : "true"
    buildConfigField "boolean", "DEV_PAGE_ENABLED", devPageEnabled.toString()

    // Enhanced test instrumentation with JaCoCo and Ultron/Allure
    testInstrumentationRunner "com.atiurin.ultron.allure.UltronAllureTestRunner"
    testInstrumentationRunnerArguments = [
        'coverage': 'true',
        'jacoco-agent.destfile': '/data/data/com.github.quarck.calnotify/files/coverage.ec',
        'jacoco-agent.includes': 'com.github.quarck.calnotify.*'
    ]

    externalNativeBuild {
      cmake{
        abiFilters 'x86_64', 'arm64-v8a'
      }
    }
    
    ndk { 
      abiFilters 'x86_64', 'arm64-v8a'
    }

    // Add packagingOptions to include necessary .so files
    packagingOptions {
      pickFirst '**/*.so'
    }

  }

  configurations {
    all*.exclude group: 'xpp3', module: 'xpp3'
  }

  // Define specific build variants for each architecture
  flavorDimensions "abi"
  
  // Get the architecture from environment variable or project property or default to supporting both
  def buildArch = providers.gradleProperty('BUILD_ARCH')
    .orElse(providers.environmentVariable('BUILD_ARCH'))
    .forUseAtConfigurationTime()

  println "Building for architecture: ${buildArch.orNull ?: 'defaulting to x86_64'}"
  
  productFlavors {
    // Only create arm64v8a flavor if specifically requested
    if (buildArch.orNull == "arm64-v8a") {
      arm64v8a {
        dimension "abi"
        versionNameSuffix "-arm64-v8a"
        ndk {
          abiFilters 'arm64-v8a'  // Only include arm64-v8a libraries
        }
      }
    }
    
    // Create x8664 flavor if specifically requested or no arch specified (default)
    if (buildArch.orNull == "x86_64" || buildArch.orNull == null) {
      x8664 {
        dimension "abi"
        versionNameSuffix "-x86_64"
        ndk {
          abiFilters 'x86_64'  // Only include x86_64 libraries
        }
      }
    }
  }

  buildTypes {
    debug {
      testCoverageEnabled true
      // Add dexOptions for faster builds
      dexOptions {
        javaMaxHeapSize "4g"
        preDexLibraries true
        threadCount = 4
      }
      ndk {
        abiFilters 'x86_64', 'arm64-v8a'
      }
    }
    release {
      testCoverageEnabled true
      minifyEnabled false
      proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
      
      // Add dexOptions for faster builds
      dexOptions {
        javaMaxHeapSize "4g"
        preDexLibraries true
        threadCount = 4
      }

      lintOptions {
        disable 'MissingTranslation'
        abortOnError false
      }
      ndk {
        abiFilters 'x86_64', 'arm64-v8a'
      }
    }

    customDebugType {
      initWith debug
      matchingFallbacks = ['debug']
      debuggable true
    }
  }

  sourceSets {
    main {
      java.srcDirs += 'src/main/kotlin'
      // Add JNI libs directory
      jniLibs.srcDirs = ['src/main/jniLibs']
    }
  }
  namespace 'com.github.quarck.calnotify'

  // Optimize for parallel execution with GitHub runners
  dexOptions {
    javaMaxHeapSize "4g"
    preDexLibraries true
    threadCount = 4
  }

  // Add proper JaCoCo instrumentation for tests
  testOptions {
    unitTests.all {
      jacoco {
        includeNoLocationClasses = true
        excludes = ['jdk.internal.*']
      }
    }
    // Add Robolectric configuration
    unitTests {
      includeAndroidResources = true
    }
  }
}

// React Native configuration for RN 0.76+
// NOTE: All react {} configuration is consolidated at the bottom of this file

// KSP avoids the SQLite JDBC native library extraction issue that KAPT has on Windows
// Room arguments can be passed via: ksp { arg("room.schemaLocation", "...") } if needed

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    // Kotlin
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"

    // AndroidX
    // https://mvnrepository.com/artifact/androidx.legacy/legacy-support-v4
    implementation "androidx.legacy:legacy-support-v4:1.0.0"
    implementation "androidx.core:core:$android_core_version"
    implementation "androidx.core:core-ktx:$android_core_version"
    implementation "androidx.appcompat:appcompat:$androidx_lib_version"

    // https://mvnrepository.com/artifact/androidx.recyclerview/recyclerview
    implementation "androidx.recyclerview:recyclerview:1.3.2"

    // https://mvnrepository.com/artifact/androidx.cardview/cardview
    implementation "androidx.cardview:cardview:1.0.0"

    // https://mvnrepository.com/artifact/androidx.palette/palette
    implementation "androidx.palette:palette:1.0.0"

    // Material
    // https://mvnrepository.com/artifact/com.google.android.material/material
    implementation "com.google.android.material:material:1.12.0"
    
    // AndroidX Preference (for modern settings UI with DayNight support)
    implementation "androidx.preference:preference-ktx:1.2.1"
    
    // Navigation Component (for tabbed UI with fragments)
    implementation "androidx.navigation:navigation-fragment-ktx:2.7.7"
    implementation "androidx.navigation:navigation-ui-ktx:2.7.7"
    
    // React Native
    implementation "com.facebook.react:react-android"
    implementation "com.facebook.react:hermes-android"
    
    // Local Expo module (for direct Kotlin imports of JsRescheduleConfirmationObject)
    implementation project(':my-module')

    // SQLite
    implementation('com.github.requery:sqlite-android:3.45.0') {
        exclude group: 'com.android.support'
        exclude module: 'support-v4'
        // Force specific version to avoid dynamic version resolution
        version {
            strictly '3.45.0'
        }
    }
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
  // Unit test dependencies
    testImplementation 'junit:junit:4.13.2'
    // Add Robolectric dependency
    testImplementation 'org.robolectric:robolectric:4.16'
    // Mockito for unit tests
    testImplementation 'org.mockito:mockito-core:5.16.1'
    testImplementation 'org.mockito.kotlin:mockito-kotlin:5.4.0'
    // MockK for unit tests
    testImplementation 'io.mockk:mockk:1.13.9' // Use standard mockk for unit tests

//    testImplementation 'io.mockk:mockk-android:1.13.9'
//    testImplementation 'io.mockk:mockk-agent:1.13.9'
    
    // Add AndroidX Test dependencies for unit tests
    testImplementation 'androidx.test:core:1.5.0'
    testImplementation 'androidx.test:core-ktx:1.5.0'
    testImplementation 'androidx.test.ext:junit:1.1.5'
    testImplementation 'androidx.test.ext:junit-ktx:1.1.5'
    // Fragment testing for Robolectric (must be debugImplementation so EmptyFragmentActivity is available)
    debugImplementation "androidx.fragment:fragment-testing:$androidx_lib_version"

  // Test dependencies - use same versions as main app to avoid conflicts
    androidTestImplementation "androidx.core:core:$android_core_version"
    androidTestImplementation "androidx.core:core-ktx:$android_core_version"
    androidTestImplementation "androidx.appcompat:appcompat:$androidx_lib_version"
    androidTestImplementation "androidx.appcompat:appcompat-resources:$androidx_lib_version"
    androidTestImplementation "androidx.fragment:fragment:$androidx_lib_version"
    androidTestImplementation "androidx.lifecycle:lifecycle-runtime:2.5.1"
    androidTestImplementation "androidx.lifecycle:lifecycle-viewmodel:2.5.1"
    androidTestImplementation "androidx.annotation:annotation:1.4.0"
    androidTestImplementation "androidx.vectordrawable:vectordrawable:1.1.0"
    androidTestImplementation "androidx.vectordrawable:vectordrawable-animated:1.1.0"
    androidTestImplementation "androidx.activity:activity:1.4.0"
    androidTestImplementation "androidx.activity:activity-ktx:1.4.0"
    androidTestImplementation "com.google.android.material:material:1.6.1"
    
    // Android Testing Dependencies
    androidTestImplementation 'androidx.test:runner:1.5.2'
    androidTestImplementation 'androidx.test:rules:1.5.0'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'  // Downgraded for Ultron 2.3.1 compatibility
    androidTestImplementation 'junit:junit:4.13.2'
    
    // Ultron UI Testing Framework (for traditional View-based UI tests)
    // Using 2.3.1 for Kotlin 1.9.x compatibility (2.6.x requires Kotlin 2.x)
    androidTestImplementation 'com.atiurin:ultron:2.3.1'
    androidTestImplementation 'com.atiurin:ultron-allure:2.3.1'
    
    // Additional test dependencies
    androidTestImplementation 'androidx.test:core:1.5.0'
    androidTestImplementation 'androidx.test:core-ktx:1.5.0'
    androidTestImplementation 'androidx.test.ext:junit-ktx:1.1.5'

    // Mockito dependencies
    androidTestImplementation 'org.mockito:mockito-core:5.16.1'
    androidTestImplementation 'org.mockito.kotlin:mockito-kotlin:5.4.0'
    
    // MockK for Kotlin mocking
    androidTestImplementation 'io.mockk:mockk-android:1.13.9'
    androidTestImplementation 'io.mockk:mockk-agent:1.13.9'

    // Jacoco
    androidTestImplementation 'org.jacoco:org.jacoco.core:0.8.12'
    
    // Room database library
    // See docs/dev_todo/database_modernization_plan.md
    // Note: Room 2.7.0+ required for Kotlin 2.0.x metadata compatibility
    // https://developer.android.com/jetpack/androidx/releases/room
    def roomVersion = "2.8.4"
    implementation "androidx.room:room-runtime:$roomVersion"
    implementation "androidx.room:room-ktx:$roomVersion"
    ksp "androidx.room:room-compiler:$roomVersion"
    // Room 2.8+ uses the new androidx.sqlite library
    implementation "androidx.sqlite:sqlite:2.6.2"
    implementation "androidx.sqlite:sqlite-framework:2.6.2"
    // Room testing support
    androidTestImplementation "androidx.room:room-testing:$roomVersion"
}

// https://reactnative.dev/docs/react-native-gradle-plugin
react {
  entryFile = layout.projectDirectory.file("../../index.tsx").asFile
  // Autolinking - adds dependencies for all autolinked libraries
  autolinkLibrariesWithApp()
  
  // Use wrapper script that skips Metro if bundle already exists
  // This works around NativeWind Windows ESM issues
  // Pre-bundle on WSL: yarn bundle:android --dev=true
  // Then Windows builds will use the existing bundle
  cliFile = layout.projectDirectory.file("../../scripts/bundle_or_skip.js").asFile
}

// Fix task dependency for RN 0.76+ autolinking (Gradle 8.7 strict validation)
// Must declare both dependsOn AND input directory for Gradle to accept the dependency
afterEvaluate {
  def autolinkTask = tasks.findByName('generateAutolinkingPackageList')
  if (autolinkTask != null) {
    def autolinkingDir = file("${buildDir}/generated/autolinking/src/main/java")
    
    // Wire Kotlin compile tasks
    tasks.matching { it.name.matches('compile.*Kotlin') }.configureEach { task ->
      task.dependsOn(autolinkTask)
      // Declare the directory as an input so Gradle knows about the dependency
      task.inputs.dir(autolinkingDir)
        .withPropertyName('autolinkingSources')
        .withPathSensitivity(PathSensitivity.RELATIVE)
        .optional()
    }
    
    // Wire Java compile tasks too
    tasks.matching { it.name.matches('compile.*JavaWithJavac') }.configureEach { task ->
      task.dependsOn(autolinkTask)
      task.inputs.dir(autolinkingDir)
        .withPropertyName('autolinkingSources')
        .withPathSensitivity(PathSensitivity.RELATIVE)
        .optional()
    }
    
    // Wire KSP tasks (Room annotation processor)
    tasks.matching { it.name.matches('ksp.*Kotlin') }.configureEach { task ->
      task.dependsOn(autolinkTask)
      task.inputs.dir(autolinkingDir)
        .withPropertyName('autolinkingSources')
        .withPathSensitivity(PathSensitivity.RELATIVE)
        .optional()
    }
  }
}

// Configure JaCoCo properly
jacoco {
    toolVersion = "0.8.14"
}

// Configure all tests to use JaCoCo instrumentation
tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

// Create a task to generate unit test coverage CSV report
// The Android Gradle Plugin's createX8664DebugUnitTestCoverageReport generates HTML and XML
// but doesn't support CSV output, so we create a separate JaCoCo task for CSV generation
task jacocoUnitTestReport(type: JacocoReport) {
    group = "Reporting"
    description = "Generate JaCoCo CSV report for unit tests"
    
    // Get architecture from property or environment, defaulting to x86_64
    def buildArch = providers.gradleProperty('BUILD_ARCH')
        .orElse(providers.environmentVariable('BUILD_ARCH'))
        .orElse('x86_64')
        .forUseAtConfigurationTime()
        .get()
    
    // Convert architecture to variant name format
    def archSuffix = buildArch == 'arm64-v8a' ? 'Arm64V8a' : 'X8664'
    def variantLower = archSuffix.toLowerCase()
    
    // Must run after unit test coverage report completes (which creates the .exec file)
    dependsOn "create${archSuffix}DebugUnitTestCoverageReport"
    
    reports {
        xml.required = true
        html.required = true
        csv.required = true
        
        html.outputLocation = file("${buildDir}/reports/jacoco/unitTestCoverage/html")
        xml.outputLocation = file("${buildDir}/reports/jacoco/unitTestCoverage/xml/report.xml")
        csv.outputLocation = file("${buildDir}/reports/jacoco/unitTestCoverage/csv/report.csv")
    }
    
    // Source directories
    sourceDirectories.setFrom(files([
        'src/main/java',
        'src/main/kotlin'
    ]))
    
    // Class directories - use the compiled classes from unit test builds
    classDirectories.setFrom(files([
        fileTree(
            dir: "${buildDir}",
            includes: [
                "**/tmp/kotlin-classes/${variantLower}Debug/**/*.class",
                "**/intermediates/javac/${variantLower}Debug/classes/**/*.class"
            ],
            excludes: [
                '**/R.class',
                '**/R$*.class',
                '**/BuildConfig.*',
                '**/Manifest*.*',
                '**/*Test*.*',
                '**/com/facebook/react/**',
                '**/com/facebook/hermes/**',
                '**/com/facebook/jni/**',
                '**/org/jacoco/**'
            ]
        )
    ]))
    
    // Execution data - use explicit file path for the .exec file
    // The AGP puts it in outputs/unit_test_code_coverage/{variant}UnitTest/
    def execFile = file("${buildDir}/outputs/unit_test_code_coverage/${variantLower}DebugUnitTest/test${archSuffix}DebugUnitTest.exec")
    executionData.setFrom(files(execFile))
    
    doFirst {
        println "=== JaCoCo Unit Test Report Configuration ==="
        println "Architecture: ${buildArch} (${archSuffix})"
        println "Build dir: ${buildDir}"
        println "Exec file path: ${execFile.absolutePath}"
        println "Exec file exists: ${execFile.exists()}"
        if (execFile.exists()) {
            println "Exec file size: ${execFile.length()} bytes"
        }
    }
    
    // Don't skip even if file doesn't exist at config time - it will exist at execution time
    outputs.upToDateWhen { false }
}

// Add task to generate coverage report for Android tests
task jacocoAndroidTestReport(type: JacocoReport) {
    group = "Reporting"
    description = "Generate JaCoCo coverage reports after running Android tests"
    
    
    reports {
        xml.required = true
        html.required = true
        csv.required = true
        
        // Add output directory configuration for better organization
        html.outputLocation = file("${buildDir}/reports/jacoco/jacocoAndroidTestReport/html")
        xml.outputLocation = file("${buildDir}/reports/jacoco/jacocoAndroidTestReport/xml/report.xml")
        csv.outputLocation = file("${buildDir}/reports/jacoco/jacocoAndroidTestReport/csv/report.csv")
    }
    
    // Get architecture from property or environment, defaulting to x86_64
    def buildArch = providers.gradleProperty('BUILD_ARCH')
        .orElse(providers.environmentVariable('BUILD_ARCH'))
        .orElse('x86_64')
        .forUseAtConfigurationTime()
        .get()
    
    // Convert architecture to variant name format
    def archSuffix = buildArch == 'arm64-v8a' ? 'Arm64V8a' : 'X8664'
    
    // Dynamic paths based on architecture
    def debugVariant = "${archSuffix.toLowerCase()}Debug"
    
    println "Generating JaCoCo report for ${debugVariant} variant"
    
    // Correct source directories to include Kotlin files
    sourceDirectories.setFrom(files([
        'src/main/java',
        'src/main/kotlin'
    ]))
    
    // Use a more targeted approach for class directories
    classDirectories.setFrom(files([
        fileTree(
            dir: "${buildDir}",
            includes: [
                "**/tmp/kotlin-classes/${debugVariant}/**/*.class",
                "**/intermediates/javac/${debugVariant}/classes/**/*.class"
            ],
            excludes: [
                '**/R.class',
                '**/R$*.class',
                '**/BuildConfig.*',
                '**/Manifest*.*',
                '**/*Test*.*',
                '**/com/facebook/react/**',
                '**/com/facebook/hermes/**',
                '**/com/facebook/jni/**',
                '**/org/jacoco/**',
                '**/com/android/tools/jacoco/**'
            ]
        )
    ]))
    
    // Look for the coverage file in ALL possible locations
    executionData.setFrom(fileTree(
        dir: "${buildDir}", 
        includes: [
            "**/outputs/code_coverage/*.ec",
            "**/outputs/code_coverage/**/*.ec",
            "**/outputs/code-coverage/**/*.ec",
            "**/outputs/connected/**/*.ec",
            "**/coverage/**/*.ec",
            "**/outputs/**/*.ec"
        ]
    ))
    
    doFirst {
        println "=== JaCoCo Report Configuration ==="
        println "Architecture: ${buildArch} (${archSuffix})"
        
        println "\nClass Directories:"
        classDirectories.files.each { file ->
            if (file.exists()) {
                def fileCount = 0
                if (file.isDirectory()) {
                    fileCount = file.listFiles()?.size ?: 0
                }
                println " - ${file.absolutePath} (exists with ${fileCount} files)"
            } else {
                println " - ${file.absolutePath} (directory not found)"
            }
        }
        
        println "\nInstrumented Class Search:"
        def classesFound = false
        fileTree(dir: "${buildDir}").matching { 
            include "**/classes/**/*.class"
            include "**/kotlin/compile*/**/*.class"
            include "**/intermediates/javac/**/*.class"
            include "**/tmp/kotlin-classes/**/*.class"
        }.visit { fileDetails ->
            if (fileDetails.name.endsWith(".class") && classesFound == false) {
                println " - Found instrumented classes at: ${fileDetails.file.parentFile.absolutePath}"
                classesFound = true
            }
        }
        
        println "\nCoverage Files:"
        executionData.files.each { file ->
            if (file.exists()) {
                println " - ${file.absolutePath} (exists with size ${file.length()} bytes)"
            } else {
                println " - ${file.absolutePath} (file not found)"
            }
        }
        
        // Only proceed if we have non-empty execution data
        def hasNonEmptyData = false
        executionData.files.each { file ->
            if (file.exists() && file.length() > 0) {
                println "\nâœ… Found non-empty coverage file: ${file.absolutePath} (${file.length()} bytes)"
                hasNonEmptyData = true
            }
        }
        
        if (!hasNonEmptyData) {
            println "\nâŒ No non-empty coverage files found. Report will be empty."
            println "Try running the tests again with: ./scripts/run_android_tests.sh"
        }
    }
    
    // Skip the task if there are no execution data files or they're all empty
    onlyIf { 
        def hasData = false
        executionData.files.each { file ->
            if (file.exists() && file.length() > 0) {
                hasData = true
            }
        }
        return hasData
    }
}
